"""
Ignore rules for MerkleWatch.
"""
import os
import fnmatch
from pathlib import Path
from typing import List

class IgnoreRules:
    """Handle ignore patterns for file scanning."""
    
    def __init__(self, root_path: Path, ignore_file_name: str = ".merkleignore"):
        self.root_path = root_path
        self.patterns: List[str] = []
        self.ignore_file = root_path / ignore_file_name
        self.load_ignore_file()
        # Always ignore the ignore file itself
        if self.ignore_file.name not in self.patterns:
            self.patterns.append(self.ignore_file.name)
        
    def load_ignore_file(self):
        """Load patterns from ignore file if it exists."""
        if self.ignore_file.exists():
            try:
                with open(self.ignore_file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            self.patterns.append(line)
            except Exception as e:
                print(f"Error Loading Ignore file: {self.ignore_file}: {e}")
                print("Continuing without ignore patterns.")
    
    def should_ignore(self, path: Path) -> bool:
        """
        Check if a path should be ignored based on patterns.
        
        Args:
            path: Path object to check (absolute or relative to root)
            
        Returns:
            True if path should be ignored
        """
        # No patterns means nothing is ignored
        if not self.patterns:
            return False
            
        try:
            # Get path relative to root
            if path.is_absolute():
                rel_path = path.relative_to(self.root_path)
            else:
                rel_path = path
                
            # Convert to string with forward slashes for consistency
            path_str = str(rel_path).replace(os.sep, '/')
            
            # Check each pattern
            for pattern in self.patterns:
                # Handle directory patterns (ending with /)
                if pattern.endswith('/'):
                    dir_pattern = pattern.rstrip('/')
                    
                    # Match exact directory name or files inside it
                    if path_str == dir_pattern:
                        return True
                    if path_str.startswith(dir_pattern + '/'):
                        return True
                        
                    # Match if any component of the path matches the pattern
                    parts = path_str.split('/')
                    if dir_pattern in parts:
                        return True
                        
                # Glob patterns with wildcards
                elif '*' in pattern or '?' in pattern or '[' in pattern:
                    # Standard glob matching
                    if fnmatch.fnmatch(path_str, pattern):
                        return True
                    # Also try matching just the basename
                    if fnmatch.fnmatch(os.path.basename(path_str), pattern):
                        return True
                        
                # Simple name patterns (no wildcards, no slashes)
                else:
                    # Check if this exact name appears in the path
                    parts = path_str.split('/')
                    if pattern in parts:
                        return True
                    # Also try exact path match
                    if path_str == pattern:
                        return True

            return False
            
        except ValueError:
            # Path is not relative to root
            return False
        
    def save(self):
        """Save patterns to .merkleignore file."""
        try:
            with open(self.ignore_file, 'w') as f:
                f.write("# MerkleWatch Ignore Rules\n")
                f.write("# Generated by merklewatch ignore\n\n")
                for pattern in self.patterns:
                    f.write(f"{pattern}\n")
            return True
        except Exception as e:
            print(f"Error saving ignore file: {e}")
            return False

    def add_pattern(self, pattern: str):
        """Add a pattern if it doesn't exist."""
        if pattern not in self.patterns:
            self.patterns.append(pattern)
            
    def remove_pattern(self, pattern: str):
        """Remove a pattern if it exists."""
        if pattern in self.patterns:
            self.patterns.remove(pattern)
